---
title: "Hamby Data and `rtrees`"
author: "Katherine Goode"
date: "`r format(Sys.time(), '%B %d, %Y')`"
output:
  html_document:
    toc: true
    toc_depth: 3
    toc_float: true
    theme: cerulean
    highlight: textmate
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE, 
                      message = FALSE,
                      warning = FALSE, 
                      eval = TRUE,
                      cache = TRUE)
```

This journal includes a description of the Hamby datasets and models fit to the data. The specification and cleaning of the training and testing datasets are documented, and some initial visualizations of the random forest model are included. The models included are the random forest model `rtrees` and several logistic regression models. 

```{r}
# Load libraries
library(bulletr)
library(cowplot)
library(GGally)
library(glmnet)
library(plotly)
library(randomForest)
library(tidyverse)
```

# Hamby Data

### Description

The Hamby data is based on several test sets of bullets from the study described in the paper "The Identification of Bullets Fired from 10 Consecutively Rifled 9mm Ruger Pistol Barrels: A Research Project Involving 507 Participants from 20 Countries" by James E. Hamby Et. Al. In this study, sets of bullets from both "known" and "unknown" gun barrels were sent to firearm examiners around the world. The examiners were asked to use the known bullets to identify which barrels the unknown bullets came from.

The test sets were created using 1 pistol and 10 barrels. Each test set contains a total of 35 bullets, which are made up of 20 known bullets and 15 unknown bullets. The 20 known bullets were created by firing two bullets from each of the 10 barrels. These are referred to as known bullets, because when they were sent to the firearm examiners, the barrel number that each bullet was fired from was listed with the bullet. The 15 unknown bullets were created by firing 15 bullets in some manner from the 10 barrels such that at least one unknown bullet came from each barrel and no more than three unknown bullets came from the same barrel. These are referred to as the unknown bullets, because when they were sent to the firearm examiners, the barrel number that the bullet was fired from was not listed with the bullet. A total of 240 test sets were created for the study.

CSAFE has access to test sets 44, 173, and 252. The bullets were scanned 6 times using a high powered microscope to obtain an image of each of the 6 lands from the bullets. The scans for test sets 173 and 252 were done by NIST, and the scans for test set 44 was done by CSAFE. The data from these images were processed to obtain a signature associated with each land. The paper "Automatic Matching of Bullet Land Impressions" by Hare, Hofmann, and Carriquiry (https://arxiv.org/abs/1601.05788) provides more descriptions of how the signatures were obtained.

CSAFE aggregated the signatures from test sets 173 and 252 and left the signatures from test set 44 separate. Within these two groups, pairs of lands were evaluated to determine how similar the signatures from the two lands were. This was done by measuring a set of variables they determined that would capture how alike the two signatures where. Some of these variables are described in Hare, Hofmann, and Carriquiry. The vignette at https://github.com/heike/bulletxtrctr/blob/master/vignettes/features.Rmd includes some additional descriptions. Note that it was not possible to evaluate all pairs of lands due to tank rash on some of the lands. The data set created from the comparisons of test sets 173 and 252 will be referred to as `hamby173and252` throughout these journals. Hare, Hofmann, and Carriquiry used `hamby173and252` as a training data set to fit the random forest model `rtrees`. The data set created from the comparisons of test sets 44 will be referred to as `hamby44` and is not used in this research project.

Both the training and the testing data will require the use of a vector of the names of the features used in the `rtrees` random forest included in the bulletr library. I created such a vector to use in this journal, and this vector is printed below. It includes nine features.

```{r}
# Obtain features used when fitting the rtrees random forest
rf_features <- rownames(bulletr::rtrees$importance)
rf_features
```

At some point, I would like to write down definitions of all the features.

- ccf: 
- cms:
- D: 
- matches: 
- mismatches:
- non_cms:
- rough_cor: 
- sd_D:
- sum_peaks:

### Training Data

This was originally a part of a journal entry that I wrote in my 'Case Studies with LIME' repository. I took the code that I used to clean the training dataset from that entry and updated it in this entry. It should still produce essentially the same dataset (with some possible changes to the level names of some of the barrels due to a 'factor' issue). The dataset that gets saved from this journal is the one that I am using for this research project.

**Raw Data**

The dataset loaded in below is the original Hamby 172 and 252 dataset that Heike gave to me. Note that when the `hamby173and252` dataset is read in, the studies called "Cary" are excluded. The data file contains rows based on bullet scans from a different study. These rows are no longer being included since Heike has found the study they came from to be poorly executed. 

```{r}
# Load in the Hamby 173 and 252 dataset
hamby173and252_raw <- read.csv("../../../data/raw/features-hamby173and252.csv") %>%
  filter(study1 != "Cary", study2 != "Cary") %>%
  mutate(study1 = factor(study1), 
         study2 = factor(study2))
```

**Number of Rows**

If we include symmetric comparisons, each set of test bullets should result in a dataset with
  $$(35 \mbox{ bullets} \times 6 \mbox{ lands})^2=44100 \mbox{ rows},$$
where a row would contain information on a pair of lands. If we do not include the symmetric comparisons, then the dataset should have
  $$\frac{(44100 \mbox{ rows} - (35 \mbox{ bullets} \times 6))}{2} + (35 \mbox{ bullets} \times 6) = 22155 \mbox{ rows}.$$
However, when I looked at the dimension of the datasets, neither of these seem to be the case. See the R code and output below. Note that `hamby173` is currently incorrectly labelled as `hamby44`. Both test sets have less than but close to 22,155 rows. This suggests that these do not include symmetric comparisons. When I checked with Heike, she confirmed that this is the case. This table also shows that there are comparisons across `hamby173` and `hamby252`. These missing observations will be explored more in the next section.

```{r}
# Summary of the number of observations in the Hamby173and252 datase
table(hamby173and252_raw$study1, hamby173and252_raw$study2)
```

**Missing Observations**

The plot below considers the number of observations within a barrel and bullet comparison from all known cases in the Hamby 173 and 252 data. We can see that the observations on the lower diagonals are missing in all cases which confirms that the symmetric comparisons were not included in the data. Additionally, a handful of cases have less than 36 observations. For the comparisons within the Hamby 173 or Hamby 252 study, the cells on the diagonals are less than 36, because none of the repeats from the symmetric comparisons of lands are included. The cells above the diagonal with less than 36 observations are missing some observations due to tank rash. For the comparisons across studies, the cases with less than expected are also due to tank rash. For some reason, the comparisons between bullets 1 from Hamby 173 and Hamby 252, the cells are being colored grey even though they have 36 observations. I am not sure why this is...

```{r}
# Create the plot to look at number of comparisons within the known bullets
countplot <- hamby173and252_raw %>%
  filter(barrel1 %in% c("1", "2", "3", "4", "5", "6", "7", "8", "9", "10"),
         barrel2 %in% c("1", "2", "3", "4", "5", "6", "7", "8", "9", "10")) %>%
  group_by(study1, study2, barrel1, barrel2, bullet1, bullet2) %>%
  summarise(count = n()) %>%
  ggplot(aes(x = barrel1, y = barrel2)) +
  geom_tile(aes(fill = count)) + 
  facet_grid(study1 + bullet1 ~ study2 + bullet2, scales = "free") +
  theme_minimal() + 
  scale_fill_distiller(palette = "GnBu", direction = 1)

# Make the plot interactive
ggplotly(countplot, width = 800, height = 700) %>%
  shiny::div(align = "center")
```

**Data Cleaning**

The code below cleans the training data. The cleaning involves:

- correcting the study 173 labels
- adjusting the bullet and barrel values for the unknowns
- renaming the match variable as samesource
- selecting the desired variables

```{r}
# Determine the letters associated with the unknown bullets
letters <- levels(hamby173and252_raw$barrel1)[11:length(levels(hamby173and252_raw$barrel1))]

# Cleaning the testing data
hamby173and252_train_cleaning <- hamby173and252_raw %>%
  mutate(study1 = fct_recode(study1, "Hamby173" = "Hamby44"),
         study2 = fct_recode(study2, "Hamby173" = "Hamby44"),
         bullet1 = factor(ifelse(barrel1 %in% letters,
                                 as.character(barrel1),
                                 as.character(bullet1))),
         barrel1 = factor(ifelse(barrel1 %in% letters, 
                                 as.character("Unknown"), 
                                 as.character(barrel1))),
         bullet2 = factor(ifelse(barrel2 %in% letters,
                                 as.character(barrel2),
                                 as.character(bullet2))),
         barrel2 = factor(ifelse(barrel2 %in% letters, 
                                 as.character("Unknown"), 
                                 as.character(barrel2))),
         land1 = factor(land1),
         land2 = factor(land2),
         rfscore = predict(bulletr::rtrees, hamby173and252_raw %>%
                             select(rf_features), 
                           type = "prob")[,2]) %>%
  rename(samesource = match) %>%
  select(study1, barrel1, bullet1, land1, study2, barrel2, bullet2, land2,
         rf_features, samesource, rfscore)
```

**Removing Bullets with Tank Rash**

I discovered that the number of rtrees predictions does not match the length of my training data. I need to ask Heike about this.

```{r}
# Compare the dimensions of my training data and the number of predictions from rtrees
dim(hamby173and252_train_cleaning)
dim(predict(bulletr::rtrees, type = "prob"))
```

When I talked to Heike about this, she told me that this training dataset probably still contains the four land impressions that had tank ranks and were removed before `rtrees` was fit. When I looked in Eric's paper, it said that the lands that were removed were the following four: 

- barrel 6 bullet 2-1
- barrel 9 bullet 2-4
- unknown bullet B-2
- unknown bullet Q-4

The code below removes any comparisons from the testing data that include one of these lands.

```{r}
# Remove the comparisons involving the four lands with tank rash
hamby173and252_train <- hamby173and252_train_cleaning %>%
  mutate(bbl1 = barrel1:bullet1:land1,
         bbl2 = barrel2:bullet2:land2) %>%
  filter(!(bbl1 %in% c("6:2:1", "9:2:4", "Unknown:B:2", "Unknown:Q:4") | 
           bbl2 %in% c("6:2:1", "9:2:4", "Unknown:B:2", "Unknown:Q:4"))) %>%
  select(-bbl1, -bbl2)
```

When I look at the dimensions of my training data now and the number of predictions from `rtrees`, then agree now!

```{r}
# Compare the dimensions of my further cleaned training data and the
# number of predictions from rtrees
dim(hamby173and252_train)
dim(predict(bulletr::rtrees, type = "prob"))
```

It is possible that the labels that Eric was using are different from the labels in my training dataset. In order to check whether I removed the correct datapoints, Heike suggested that I look at a parallel coordinate plots to see if the observations that were removed stand out as being unusual compared to the rest of the data. The code below prepares the training data before observations were removed to be plotted.

```{r}
# Create dataset for creating the paralle coordinate plot
par_data <- hamby173and252_train_cleaning %>%
  mutate(bbl1 = barrel1:bullet1:land1,
         bbl2 = barrel2:bullet2:land2) %>%
  mutate(category = factor(ifelse(!(bbl1 %in% c("6:2:1", "9:2:4", "Unknown:B:2",
                                                "Unknown:Q:4") | 
                                      bbl2 %in% c("6:2:1", "9:2:4", "Unknown:B:2",
                                                  "Unknown:Q:4")),
                           "keep", "remove"))) %>%
  arrange(category) %>%
  mutate(samesource_colors = ifelse(samesource == TRUE, rgb(1, 0, 0, alpha = 0.05), 
                                    rgb(0, 0, 0, alpha = 0.001)),
         samesource_colors2 = ifelse(samesource == TRUE, rgb(1, 0, 0, alpha = 0.001), 
                                    rgb(0, 0, 0, alpha = 0.01)),
         tankrash_colors = ifelse(category == "keep", rgb(0, 0, 1, alpha = 0.05),
                                  rgb(0, 0, 0, alpha = 0.01)))
```

The first plot shows the observations that were kept in black and the observations that were removed in blue. These observations do not stand out to me. It is not clear if these were the ones that were suppose to be removed or not. The second plot shows the observations from matches plotted in red, and the third plot shows the observations from nonmatches plotted in black.

```{r}
MASS::parcoord(par_data %>% select(ccf:sum_peaks), col = par_data$tankrash_colors)
MASS::parcoord(par_data %>% select(ccf:sum_peaks), col = par_data$samesource_colors)
MASS::parcoord(par_data %>% select(ccf:sum_peaks), col = par_data$samesource_colors2)
```

**Saving the Data**

The cleaned data is saved and used as the training dataset for the rest of this research project.

```{r eval = FALSE}
# Save the datasets and response variables as .csv files
write.csv(hamby173and252_train, "../../data/hamby173and252_train.csv", row.names = FALSE)
```

### Testing Data

**Raw Data**

The original data files given to me by Heike are loaded in below. For now, we are working with only sets 1 and 11 from the Hamby 224 study. She may provide me with more in the future.

```{r}
# Load in the Hamby 224 datasets
hamby224_set1 <- readRDS("../../../data/raw/h224-set1-features.rds")
hamby224_set11 <- readRDS("../../../data/raw/h224-set11-features.rds")
```

**Data Cleaning**

The code below cleans the data from both sets 1 and 11. This involves:

- selecting the desired variables
- renaming the bullet and land variables
- creating study and set variables
- re-coding the bullet and land names

```{r}
# Clean the Hamby 224 set 1 data
hamby224_set1_cleaned <- hamby224_set1 %>%
  select(-bullet_score, -land1, -land2, -aligned, -striae, -features) %>%
  rename(bullet1 = bulletA,
         bullet2 = bulletB, 
         land1 = landA,
         land2 = landB) %>%
  mutate(study = factor("Hamby 224"), 
         set = factor("Set 1"),
         bullet1 = recode(factor(bullet1), 
                          "1" = "Known 1", "2" = "Known 2", "Q" = "Questioned"),
         bullet2 = recode(factor(bullet2), 
                          "1" = "Known 1", "2" = "Known 2", "Q" = "Questioned"),
         land1 = recode(factor(land1), 
                        "1" = "Land 1", "2" = "Land 2", "3" = "Land 3", 
                        "4" = "Land 4", "5" = "Land 5", "6" = "Land 6"),
         land2 = recode(factor(land2), 
                        "1" = "Land 1", "2" = "Land 2", "3" = "Land 3", 
                        "4" = "Land 4", "5" = "Land 5", "6" = "Land 6")) %>%
  select(study, set, bullet1:land2, rf_features, rfscore, samesource)

# Clean the Hamby 224 set 11 data
hamby224_set11_cleaned <- hamby224_set11 %>%
  select(-bullet_score, -land1, -land2, -aligned, -striae, -features) %>%
  rename(bullet1 = bulletA,
         bullet2 = bulletB, 
         land1 = landA,
         land2 = landB) %>%
  mutate(study = factor("Hamby 224"), 
         set = factor("Set 11"),
         bullet1 = recode(factor(bullet1), 
                          "Bullet 1" = "Known 1", "Bullet 2" = "Known 2", 
                          "Bullet I" = "Questioned"),
         bullet2 = recode(factor(bullet2), 
                          "Bullet 1" = "Known 1", "Bullet 2" = "Known 2", 
                          "Bullet I" = "Questioned")) %>%
  select(study, set, bullet1:land2, rf_features, rfscore, samesource)
```

The cleaned data from sets 1 and 11 are combined below into the testing dataset. Rows are added for the missing comparisons from the Hamby 224 study, and some additional cleaning is done.

```{r}
# Create a dataset with all combinations of lands and bullets comparisons for each set
combinations <- data.frame(set = factor(rep(c("Set 1", "Set 11"), each = 324)),
                    expand.grid(land1 = factor(c("Land 1", "Land 2", "Land 3", 
                                                 "Land 4", "Land 5", "Land 6")),
                                land2 = factor(c("Land 1", "Land 2", "Land 3", 
                                                 "Land 4", "Land 5", "Land 6")),
                                bullet1 = factor(c("Known 1", "Known 2", "Questioned")),
                                bullet2 = factor(c("Known 1", "Known 2", "Questioned"))))

# Join the two cleaned Hamby 224 sets into one testing set
hamby224_test <- suppressWarnings(bind_rows(hamby224_set1_cleaned,
                                            hamby224_set11_cleaned)) %>%
  mutate(set = factor(set),
         bullet1 = factor(bullet1),
         bullet2 = factor(bullet2),
         land1 = factor(land1),
         land2 = factor(land2)) %>%
  right_join(combinations, by = c("set", "land1", "land2", "bullet1", "bullet2")) %>%
  filter(!(bullet1 == "Questioned" & bullet2 == "Known 1"),
         !(bullet1 == "Questioned" & bullet2 == "Known 2"),
         !(bullet1 == "Known 2" & bullet2 == "Known 1")) %>%
  arrange(rfscore) %>%
  mutate(case = factor(1:length(study))) %>%
  select(case, study:samesource)
```

**Saving the Data**

The testing data file is saved below.

```{r eval = FALSE}
# Save the test data as a .csv file
write.csv(hamby224_test, "../../data/hamby224_test.csv", row.names = FALSE)
```

### Plots of Features

##### Distributions by `samesource`

I created the following two plots of the training data as suggested by Heike. The histograms below show the distributions of the features used in the random forest `rtrees`. The histograms are filled by the `samesource` variable, which is the truth of whether or not the comparison is from the same barrel and land. The default histograms make it hard to compare the distributions of the matches and non-matches since there are many more comparisons that have `samesource == FALSE`.

```{r}
# Create plots of the feature distributions colored by samesource for the training data
hamby173and252_train %>% 
  select(rf_features, samesource) %>%
  gather(key = feature, value = value, 1:9) %>%
  select(feature, value, samesource) %>%
  ggplot(aes(x = value, fill = samesource)) + 
  geom_histogram(bins = 30) + 
  facet_wrap( ~ feature, scales = "free") +
  labs(x = "Variable Value", y = "Frequency", fill = "Same Source?",
       title = "Hamby 173 and 252 Training Data") +
  theme_bw() +
  theme(legend.position = "bottom")
```

By setting `position = "fill"` in the `geom_histogram` function, it is easier to compare the matches and non-matches. <span style="color:teal"> These plots could be used in the future to hand select the bins for lime. Additionally, fitting a logistic regression to this data could also be used to determine the LC50, LC10, ad LC90, which could be used as the bins for lime. </span>

```{r}
# Create plots of the feature distributions colored by samesource for the training data
# using the position = "fill" option
hamby173and252_train %>% 
  select(rf_features, samesource) %>%
  gather(key = feature, value = value, 1:9) %>%
  select(feature, value, samesource) %>%
  ggplot(aes(x = value, fill = samesource)) + 
  geom_histogram(position = "fill", bins = 30) + 
  facet_wrap( ~ feature, scales = "free") +
  labs(x = "Variable Value", y = "Proportion", fill = "Same Source?",
       title = "Hamby 173 and 252 Training Data") +
  theme_bw() +
  theme(legend.position = "bottom")
```

The plots below have the same structure, but they are created with the Hamby 224 testing data. I chose to not separate the testing data by sets, but this is something that could be done later if necessary.

```{r}
# Create plots of the feature distributions colored by samesource for the testing data
hamby224_test %>% 
  select(rf_features, samesource) %>%
  gather(key = feature, value = value, 1:9) %>%
  select(feature, value, samesource) %>%
  ggplot(aes(x = value, fill = samesource)) + 
  geom_histogram(bins = 15) + 
  facet_wrap( ~ feature, scales = "free") +
  labs(x = "Variable Value", y = "Frequency", fill = "Same Source?",
       title = "Hamby 224 Testing Data") +
  theme_bw() +
  theme(legend.position = "bottom")
```

```{r}
# Create plots of the feature distributions colored by samesource for the testing 
# data using the position = "fill" option
hamby224_test %>% 
  select(rf_features, samesource) %>%
  gather(key = feature, value = value, 1:9) %>%
  select(feature, value, samesource) %>%
  ggplot(aes(x = value, fill = samesource)) + 
  geom_histogram(position = "fill", bins = 15) + 
  facet_wrap( ~ feature, scales = "free") +
  labs(x = "Variable Value", y = "Proportion", fill = "Same Source?",
       title = "Hamby 224 Testing Data") +
  theme_bw() +
  theme(legend.position = "bottom")
```

##### Feature Interactions

```{r}
hamby224_test %>%
  select(rf_features, samesource) %>%
  ggpairs(mapping = aes(color = samesource), 
          columns = rf_features)
```


##### Correlations

I made these plots to look at the correlation between features in the training data within the TRUE and FALSE cases of samesource. The features are highly correlated for the match comparisons. It is clear that the variables are more correlated with the match comparisons than the non-match comparisons. However, there are still some variables that are relatively highly correlation with the non-match comparisons.

```{r fig.height = 4, fig.width = 9}
# Create a correlation heatmap of the match comparisons in the training data
cor_match <- hamby173and252_train %>%
  select(rf_features, samesource) %>%
  filter(samesource == TRUE) %>%
  select(-samesource) %>%
  cor() %>%
  reshape2::melt() %>%
  mutate(Var1 = factor(Var1, levels = c("ccf", "cms", "matches", "rough_cor", "sum_peaks",
                                        "D", "sd_D", "mismatches", "non_cms")),
         Var2 = factor(Var2, levels = c("ccf", "cms", "matches", "rough_cor", "sum_peaks",
                                        "D", "sd_D", "mismatches", "non_cms"))) %>%
  ggplot(aes(x = Var1, y = Var2, fill = value)) + 
  geom_tile() + 
  scale_fill_gradient2(limits = c(-1, 1)) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        legend.position = "none") + 
  labs(x = "", y = "", fill = "Correlation",
       title = "Match Comparisons")

# Create a correlation heatmap of the non-match comparisons in the training data
cor_nonmatch <- hamby173and252_train %>%
  select(rf_features, samesource) %>%
  filter(samesource == FALSE) %>%
  select(-samesource) %>%
  cor() %>%
  reshape2::melt() %>%
  mutate(Var1 = factor(Var1, levels = c("ccf", "cms", "matches", "rough_cor", "sum_peaks",
                                        "D", "sd_D", "mismatches", "non_cms")),
         Var2 = factor(Var2, levels = c("ccf", "cms", "matches", "rough_cor", "sum_peaks",
                                        "D", "sd_D", "mismatches", "non_cms"))) %>%
  ggplot(aes(x = Var1, y = Var2, fill = value)) + 
  geom_tile() + 
  scale_fill_gradient2(limits = c(-1, 1)) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        legend.position = "none") +
  labs(x = "", y = "", fill = "Correlation",
       title = "Non-Match Comparisons")

# Create a title for the panel of plots
cor_title <- ggdraw() +
  draw_label("Correlation of Feature Variables in the Training Data", 
             fontface = "bold", 
             size = 16,
             x = 0.5,
             hjust = 0.5)

# Create a joined legend for the panel of plots
cor_legend <- get_legend(cor_match + theme(legend.position = "right"))

# Create the panel of plots
plot_grid(cor_title, 
          plot_grid(cor_match, cor_nonmatch, cor_legend, ncol = 3, rel_widths = c(2, 2, 0.5)),
          ncol = 1,
          rel_heights = c(0.25, 3))
```

The plots below show the correlations for the testing data. The patterns in the plots look really similar to ones of the training data.

```{r fig.height = 4, fig.width = 9}
# Create a correlation heatmap of the match comparisons in the training data
cor_match_test <- hamby224_test %>%
  select(rf_features, samesource) %>%
  filter(samesource == TRUE) %>%
  select(-samesource) %>%
  cor() %>%
  reshape2::melt() %>%
  mutate(Var1 = factor(Var1, levels = c("ccf", "cms", "matches", "rough_cor", "sum_peaks",
                                        "D", "sd_D", "mismatches", "non_cms")),
         Var2 = factor(Var2, levels = c("ccf", "cms", "matches", "rough_cor", "sum_peaks",
                                        "D", "sd_D", "mismatches", "non_cms"))) %>%
  ggplot(aes(x = Var1, y = Var2, fill = value)) + 
  geom_tile() + 
  scale_fill_gradient2(limits = c(-1, 1)) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        legend.position = "none") + 
  labs(x = "", y = "", fill = "Correlation",
       title = "Match Comparisons")

# Create a correlation heatmap of the non-match comparisons in the training data
cor_nonmatch_test <- hamby224_test %>%
  select(rf_features, samesource) %>%
  filter(samesource == FALSE) %>%
  select(-samesource) %>%
  cor() %>%
  reshape2::melt() %>%
  mutate(Var1 = factor(Var1, levels = c("ccf", "cms", "matches", "rough_cor", "sum_peaks",
                                        "D", "sd_D", "mismatches", "non_cms")),
         Var2 = factor(Var2, levels = c("ccf", "cms", "matches", "rough_cor", "sum_peaks",
                                        "D", "sd_D", "mismatches", "non_cms"))) %>%
  ggplot(aes(x = Var1, y = Var2, fill = value)) + 
  geom_tile() + 
  scale_fill_gradient2(limits = c(-1, 1)) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        legend.position = "none") +
  labs(x = "", y = "", fill = "Correlation",
       title = "Non-Match Comparisons")

# Create a title for the panel of plots
cor_title_test <- ggdraw() +
  draw_label("Correlation of Feature Variables in the Testing Data", 
             fontface = "bold", 
             size = 16,
             x = 0.5,
             hjust = 0.5)

# Create a joined legend for the panel of plots
cor_legend_test <- get_legend(cor_match_test + theme(legend.position = "right"))

# Create the panel of plots
plot_grid(cor_title_test, 
          plot_grid(cor_match_test, cor_nonmatch_test, cor_legend_test, 
                    ncol = 3, rel_widths = c(2, 2, 0.5)),
          ncol = 1,
          rel_heights = c(0.25, 3))
```

# Random Forest: `rtrees`

### Description

The random forest model that was fit to the Hamby training dataset is discussed in the paper "Automatic Matching of Bullet Land Impressions" by E. Hare Et. Al. The model is available through the GitHub version of the `bulletr` package. The link to the GitHub repository for `bulletr` is https://github.com/CSAFE-ISU/bulletr. 

The random forest model is stored in the package `bulletr` as a data object called `rtrees`. The paper does not include many details about the model fitting process, so I looked at some of the model features, which are printed below. These values told me that the model was fit using the predictive features of `ccf`, `rough_cor`, `D`, `sd_D`, `matches`, `mismatches`, `cms`, `non_cms`, and `sum_peaks` with 300 trees and the parameter of `mtry` set to 3, which is the "number of variables randomly sampled as candidates at each split" as explained in the `randomforest` package documentation.

```{r}
# Importance values from the random forest
rtrees$importance

# The number of trees used in the random forest
rtrees$ntree

# "Number of variables randomly sampled as candidates at each split"
rtrees$mtry
```

### Visualizations

##### Random Forest Scores

**Facet Version**

The plot below is the model for the one that will be used in the app for exploring the `lime` explanations from the bullet matching data. This is the data from set 1 of the testing dataset.

```{r}
# Heatmap of rfscore for each comparison in set 1
hamby224_test %>%
  filter(set == "Set 1") %>%
  ggplot(aes(x = land1, y = land2, label = bullet1, label2 = bullet2,
             text = paste('Bullets Compared: ', bullet1, "-", land1, 
                          "vs", bullet2, "-", land2,
                          '\nRandom Forest Score: ', 
                          ifelse(is.na(rfscore), "Missing due to tank rash", rfscore)))) +
  geom_tile(aes(fill = rfscore)) +
  facet_grid(bullet2 ~ bullet1, scales = "free") +
  theme_minimal() +
  scale_fill_gradient2(low = "darkgrey", high = "darkorange", midpoint = 0.5) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank()) +
  labs(x = "", y = "", fill = "RF Score")
```

**Individual Plots Version**

I also wrote some code to create the above plot using individual plots instead of facets. This is included below. (It is a bit outdated compared to my newer version of the plot.)

```{r}
# Code for creating the heatmap plots using individual plots
p1 <- hamby224_test %>%
  filter(set == "Set 1", bullet1 == "Known 1", bullet2 == "Known 1") %>%
  select(case, bullet1, bullet2, land1, land2, rfscore) %>%
  distinct() %>%
  ggplot(aes(x = land1, y = land2, label = bullet1, label2 = bullet2)) +
  geom_tile(aes(fill = rfscore)) +
  theme_minimal() +
  scale_fill_gradient2(low = "grey", high = "orange", midpoint = 0.5) +
  labs(x = "Land 1", y = "Land 2", fill = "RF Score") + 
  theme(legend.position = "none")

p2 <- hamby224_test %>%
  filter(set == "Set 1", bullet1 == "Known 1", bullet2 == "Known 2") %>%
  select(case, bullet1, bullet2, land1, land2, rfscore) %>%
  distinct() %>%
  ggplot(aes(x = land1, y = land2, label = bullet1, label2 = bullet2)) +
  geom_tile(aes(fill = rfscore)) +
  theme_minimal() +
  scale_fill_gradient2(low = "grey", high = "orange", midpoint = 0.5) +
  labs(x = "Land 1", y = "Land 2", fill = "RF Score") + 
  theme(legend.position = "none")

p3 <- hamby224_test %>%
  filter(set == "Set 1", bullet1 == "Known 1", bullet2 == "Questioned") %>%
  select(case, bullet1, bullet2, land1, land2, rfscore) %>%
  distinct() %>%
  ggplot(aes(x = land1, y = land2, label = bullet1, label2 = bullet2)) +
  geom_tile(aes(fill = rfscore)) +
  #facet_grid(bullet1 ~ bullet2, scales = "free") +
  theme_minimal() +
  scale_fill_gradient2(low = "grey", high = "orange", midpoint = 0.5) +
  labs(x = "Land 1", y = "Land 2", fill = "RF Score") + 
  theme(legend.position = "none")

p4 <- ggplot() + geom_blank() + theme_classic()

p5 <- hamby224_test %>%
  filter(set == "Set 1", bullet1 == "Known 2", bullet2 == "Known 2") %>%
  select(case, bullet1, bullet2, land1, land2, rfscore) %>%
  distinct() %>%
  ggplot(aes(x = land1, y = land2, label = bullet1, label2 = bullet2)) +
  geom_tile(aes(fill = rfscore)) +
  #facet_grid(bullet1 ~ bullet2, scales = "free") +
  theme_minimal() +
  scale_fill_gradient2(low = "grey", high = "orange", midpoint = 0.5) +
  labs(x = "Land 1", y = "Land 2", fill = "RF Score") + 
  theme(legend.position = "none")

p6 <- hamby224_test %>%
  filter(set == "Set 1", bullet1 == "Known 2", bullet2 == "Questioned") %>%
  select(case, bullet1, bullet2, land1, land2, rfscore) %>%
  distinct() %>%
  ggplot(aes(x = land1, y = land2, label = bullet1, label2 = bullet2)) +
  geom_tile(aes(fill = rfscore)) +
  #facet_grid(bullet1 ~ bullet2, scales = "free") +
  theme_minimal() +
  scale_fill_gradient2(low = "grey", high = "orange", midpoint = 0.5) +
  labs(x = "Land 1", y = "Land 2", fill = "RF Score") + 
  theme(legend.position = "none")

p7 <- ggplot() + geom_blank() + theme_classic()

p8 <- ggplot() + geom_blank() + theme_classic()

p9 <- hamby224_test %>%
  filter(set == "Set 1", bullet1 == "Questioned", bullet2 == "Questioned") %>%
  select(case, bullet1, bullet2, land1, land2, rfscore) %>%
  distinct() %>%
  ggplot(aes(x = land1, y = land2, label = bullet1, label2 = bullet2)) +
  geom_tile(aes(fill = rfscore)) +
  #facet_grid(bullet1 ~ bullet2, scales = "free") +
  theme_minimal() +
  scale_fill_gradient2(low = "grey", high = "orange", midpoint = 0.5, limits = c(0,1)) +
  labs(x = "Land 1", y = "Land 2", fill = "RF Score")

style(subplot(p1, p2, p3, p4, p5, p6, p7, p8, p9, 
              nrows = 3, 
              titleX = TRUE, 
              titleY = TRUE, 
              margin = 0.03),
      hoverinfo = "skip",
      traces = 7)
```

##### Parallel Coordinate Plots

```{r}
# Create a dataframe with the random forest features ordered by importance
rf_features_ordered <- data.frame(feature = rownames(bulletr::rtrees$importance), 
                                  MeanDecreaseGini = bulletr::rtrees$importance) %>%
  arrange(desc(MeanDecreaseGini))
```

Below is a parallel coordinate plot of the training dataset. It is facetted by `samesource` and colored by `rfscore`. The features are sorted by the variable importance scores (descending from left to right) from the `rtrees` model. It is interesting to see that the matches with low rfscores have feature values that are similar to the nonmatches.

```{r fig.width = 10}
hamby173and252_train %>%
  mutate(case = 1:n()) %>%
  select(case, rfscore, samesource, ccf:sum_peaks) %>%
  mutate_at(rf_features, scale) %>%
  gather(variable, value, 4:12) %>%
  mutate(variable = factor(variable, levels = rf_features_ordered$feature)) %>%
  ggplot(aes(x = variable, y = value, group = case, color = rfscore)) + 
  geom_point() + 
  geom_line(alpha = 0.2) + 
  facet_grid( ~ samesource) + 
  scale_color_gradient2(low = "darkgrey", high = "darkorange", midpoint = 0.5) + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) + 
  labs(x = "Feature (sorted by rtrees variable importance)", 
       y = "Standardized Feature Values")
```

Below is a parallel coordinate plot of the testing dataset. It is facetted by `samesource` and colored by `rfscore`. You can see a clear distinction between the trends of the feature values from the nonmatches and matches. It is interesting to consider the cases in set 1 that are matches but were predicted to be nonmatches by the model. These are the cases colored in grey, and their feature values are very different from the observations that were predicted to be matches by the model. The nonmatch predictions have values that are closer to the nonmatches.

```{r fig.width = 10}
hamby224_test %>%
  na.omit() %>%
  select(case, set, rfscore, samesource, ccf:sum_peaks) %>%
  mutate_at(rf_features, scale) %>%
  gather(variable, value, 5:13) %>%
  mutate(variable = factor(variable, levels = rf_features_ordered$feature)) %>%
  ggplot(aes(x = variable, y = value, group = case, color = rfscore)) + 
  geom_point() + 
  geom_line(alpha = 0.5) + 
  facet_grid(set ~ samesource) + 
  scale_color_gradient2(low = "darkgrey", high = "darkorange", midpoint = 0.5) + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) + 
  labs(x = "Feature (sorted by rtrees variable importance)", 
       y = "Standardized Feature Values")
```

##### Biplot

```{r eval = FALSE}
pca_set1 <- princomp(x = hamby224_test %>% 
                       filter(set == "Set 1") %>% 
                       select(rf_features) %>% 
                       na.omit(), 
                     cor = TRUE)
biplot(pca, col = hamby224_test %>% 
                       filter(set == "Set 1") %>% 
                       pull(rfscore))
```

# Logistic Regressions

I have been thinking a lot about it is difficult to determine whether LIME is providing reasonable explanations, because we cannot know what the random forest is doing. That is the point of LIME. Heike suggested that we fit a logistic regression model to the training bullet data. We can then apply LIME to the logistic regression and determine if the explanations match what we would expect based on the coefficients of the logistic regression that we can interpret. She also suggested including interactions in the logistic regression model. This section includes code for fitting several logisitic regression models.

### Main Effects Only

The code below fits a logistic regression model to the training data using the `train` function from the caret package. The nine features used to fit `rtrees` are included as main effects only. The features are standardized prior to fitting the model using the `preProcess = "scale"` in `train`.

```{r}
# Fit or load the logistic regression model with only main effects
if(!file.exists("../../../data/logistic_mains.rds")) {
  
  # Set a seed
  set.seed(20190226)
  
  # Fit the model
  logistic_mains <- caret::train(as.factor(samesource) ~ ccf + rough_cor + D + sd_D + 
                                   matches + mismatches + cms + non_cms + sum_peaks,
                                 preProcess = "scale",
                                 data = hamby173and252_train, 
                                 method = "glm", 
                                 family = "binomial")

  # Save the model
  saveRDS(logistic_mains, "../../../data/logistic_mains.rds")

} else{
  
  # Load the model
  logistic_mains <- readRDS("../../../data/logistic_mains.rds")
  
}
```

The output from the model is shown below. The features of ccf and matches stand out as the most important features in the model.

```{r}
# Summary of the model
summary(logistic_mains)
```

### All Two Way Interactions

The code below fits a logistic regression model to the training data using the `train` function from the caret package. The nine features used to fit `rtrees` are included as main effects and with all two way interactions. The features are standardized prior to fitting the model using the `preProcess = "scale"` in `train`.

```{r}
# Fit or load the logistic regression model with all two way interactions
if(!file.exists("../../../data/logistic_inters2.rds")) {
  
  # Set a seed
  set.seed(20190226)
  
  # Fit the model
  logistic_inters2 <- caret::train(as.factor(samesource) ~
                                       (ccf + rough_cor + D + sd_D + matches + 
                                          mismatches + cms + non_cms + sum_peaks)^2,
                                     preProcess = "scale",
                                     data = hamby173and252_train,
                                     method = "glm", 
                                     family = "binomial")
  
  # Save the model
  saveRDS(logistic_inters2, "../../../data/logistic_inters2.rds")

} else{
  
  # Load the model
  logistic_inters2 <- readRDS("../../../data/logistic_inters2.rds")
  
}
```

The output from this model is not shown.

```{r eval = FALSE}
# Summary of the model
summary(logistic_inters2)
```

### LASSO Model

```{r}
# Fit or load the lasso logistic regression model
if(!file.exists("../../../data/logistic_lasso.rds")) {
  
  # Set a seed
  set.seed(20190312)

  # LASSO logistic regression model
  logistic_lasso <- cv.glmnet(x = hamby173and252_train %>% select(rf_features) %>% as.matrix(ncol = 9), 
                              y = hamby173and252_train %>% pull(samesource) %>% as.numeric(),
                              alpha = 1,
                              family = "binomial")

  # Tell R to run the upcoming code in parallel
  # plan(multiprocess)
  
  # LASSO logistic regression model with possible pairwise interactions
  # logistic_lasso <- 
  #   hierNet.logistic.path(x = hamby173and252_train %>% select(rf_features) %>% as.matrix(ncol = 9), 
  #                         y = hamby173and252_train %>% pull(samesource) %>% as.numeric(), 
  #                         lamlist = logistic_lasso$lambda)
  
  # Save the model
  saveRDS(logistic_lasso, "../../../data/logistic_lasso.rds")
  
} else {
  
  # Load the model
  logistic_lasso <- readRDS("../../../data/logistic_lasso.rds")
  
}
```

### Comparing the Models

The results as computed by caret on the training data are shown below for the two logistic regression models. The accuracy shows that the models with two way interactions performs better on the training data.

```{r}
# Results from the models
data.frame(model = c("mains", "inters2")) %>%
  bind_cols(bind_rows(logistic_mains$results, logistic_inters2$results))
```

The AICs from the models are shown below. The model with two way interactions performs the best based on AIC.

```{r}
AIC(logistic_mains$finalModel)
AIC(logistic_inters2$finalModel)
```

I also wanted to know how the models perform on the test data. The models are used to make predictions on the test data and the MSEs are computed for each model. These are shown in the table below. The model with main effects only has the smallest MSE. I am guessing that the other model is overfitting the data.

```{r}
data.frame(obs = hamby224_test %>% 
             pull(samesource) %>% na.omit(),
           mains = predict(logistic_mains, hamby224_test %>% select(rf_features)),
           inters2 = predict(logistic_inters2, hamby224_test %>% select(rf_features))) %>%
  mutate(mains_sqerrs = (obs - as.logical(mains))^2,
         inters2_sqerrs = (obs - as.logical(inters2))^2) %>%
  summarise_at(vars(mains_sqerrs, inters2_sqerrs), 
               function(x) sum(x) / length(x)) %>%
  rename(mains_mse = mains_sqerrs, inters2_mse = inters2_sqerrs)
```


# Session Info

```{r}
sessionInfo()
```